!SESSION 2023-06-26 14:27:08.135 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=17.0.7
java.vendor=Eclipse Adoptium
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_AF
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/leidy/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/leidy/.eclipse_keyring

This is a continuation of log file /Users/leidy/eclipse-workspace/.metadata/.bak_0.log
Created Time: 2023-06-28 12:37:00.719

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:00.719
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:00.721
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-28 12:37:02.227
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;
import java.util.Scanner;

public class Examen_Final_Leidy_Zhang {
	/*
	 * Nos piden elaborar un CRM de gestión de clientes y que tendrá que gestionar a través de un
	menú de opciones las altas de un cliente, consulta de un cliente o todos los clientes, generar presupuesto,
	modificación de un cliente y eliminación de un cliente.
	*/
	static Scanner sc = new Scanner(System.in);
	static ArrayList<Cliente> clientes = new ArrayList<Cliente>();
	static Cliente nuevo = new CL
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 1. Se debe definir un cliente predefinido con los diferentes datos aportados estáticamente y
correspondientes a cada uno de los atributos.
2. Defina un nuevo e-mail por el usuario creado.
3. Genere un presupuesto con el concepto “170h. Elaboración de una API”, precio 2410 € y
con un iva 21%.
4. Genere un presupuesto con el concepto “250h. Diseño imagen corporativa”, precio
3110€ y con un iva 21%.
5. Muestre la info del cliente que ha creado mediante el método consulta de un cliente.
6. Debe definirse otro cliente con los diferentes datos aportados por el usuario y
correspondientes a cada uno de los atributos.
7. Muestre la información de todos los clientes existentes.
8. Elimine el último cliente creado.
		 */
		
		

		int opcion = 0;
		int optionVer = 0;
		
		do {
			System.out.println("Menu \n"
					+ "0. Salir de la aplicacion \n"
					+ "1. Dar de alta un cliente \n"
					+ "2. Eliminar cliente \n"
					+ "3. Modificar un cliente \n"
					+ "4. Consultar datos de un cliente o todos \n"
					+ "5. Generar presupuesto");
			
			opcion = sc.nextInt();
			sc.nextLine();
			
		switch(opcion) {
		
			case 1:
				crearCliente();
				break;	
			case 2:
				eliminarCliente();
				break;
			case 3:
				modificarCliente();
				break;
			case 4:
				System.out.println("Quiere ver: \n"
						+ "1. Un solo cliente \n"
						+ "2. Todos los clientes");
				
				optionVer = sc.nextInt();
				sc.nextLine();
				
				verClientes(optionVer);
				
				break;
			case 5:
				crearPresupuesto();
				break;	
			default:
				System.out.println("Error. Introduce una opcion entre 1-5");
		}

		}while(opcion !=0);
		
		System.out.println("Has salido de la aplicacion");
	}

	public static void crearCliente() {
		
		/*
		 * La opción alta de un cliente debe nombrar el método altaClient(), y éste a la vez deberá
	pedir al usuario que introduzca por pantalla los datos mencionados anteriormente (o deberá
	de recibir estos datos por parámetro), exceptuando el id que se tendrá que autogenerar utilizando
	Math. Una vez que haya pedido todos estos datos, debe instanciarse el objeto de la clase y
	añadirlo a un array de clientes.
		 */
		String nombre = "";
		String apellido = "";
		String direccion = "";
		String email = "";
		String comentarios = "";
		
	
		System.out.println("Introduce los datos del nuevo cliente: \n"
				+ "Nombre: ");
		nombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		apellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Direccion: ");
		direccion = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Email: ");
		email = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Comentarios: ");
		comentarios = sc.nextLine();
		sc.nextLine();
		
		Cliente nuevoCliente = new Cliente(nombre, apellido, direccion, email, comentarios);
		clientes.add(nuevoCliente);
		
		
	}
	
	public static void eliminarCliente() {
		/*
		 * La opción de eliminar un cliente debe nombrar el método darDeBaixaClient(), y éste deberá
		pedir al usuario el nombre o el id del cliente que quiere darse de baja y si el cliente está dentro de
		el array, lo eliminaremos y mostraremos un mensaje por pantalla informando al usuario que hemos eliminado
		el cliente. Si no hemos encontrado al cliente dentro del array, avisaremos al usuario diciendo que el cliente no
		estaba dentro de nuestra aplicación.
		 */
		
		String eliminarNombre = "";
		String eliminarApellido = "";
		int eliminarId = 0;
		int posicionEliminar = 0;
		
	
		System.out.println("Introduce el nombre del cliente que quieres eliminar: \n"
				+ "Nombre: ");
		eliminarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		eliminarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		eliminarId = sc.nextInt();
		sc.nextLine();
		
		
		posicionEliminar = obtenerPosicion(eliminarNombre, eliminarApellido, eliminarId);
		
		if(posicionEliminar != -1) {
			clientes.remove(posicionEliminar);
			System.out.println("El cliente se ha eliminado exitosamente");
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	}
	
	public static void modificarCliente() {
		/*
		 * La opción de modificar de un cliente, debe nombrar el método modificarClient(), y éste deberá
	pedir al usuario el nombre o el id del cliente que queremos modificar. Si lo tenemos en la aplicación, le
	preguntaremos si desea modificar cualquiera de los atributos, exceptuando el id. Haremos la modificación
	pertinente y avisaremos al usuario de que la modificación se ha realizado. En caso contrario, indicaremos en
	el usuario que no existe el cliente dentro de la aplicación.
		 */
		String modificarNombre = "";
		String modificarApellido = "";
		int modificarId = 0;
		int posicionModificar = 0;
		int opcionModificar = 0;
		
		String nuevoNombre = "";
		String nuevoApellido = "";
		String nuevoDireccion = "";
		String nuevoEmail = "";
		String nuevoComentarios = "";
		
	
		System.out.println("Introduce el cliente que quieres modificar: \n"
				+ "Nombre: ");
		modificarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		modificarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		modificarId = sc.nextInt();
		sc.nextLine();
		
		posicionModificar  = obtenerPosicion(modificarNombre, modificarApellido, modificarId);
		
		if(posicionModificar != -1) {
			//(String nombre, String apellido, String direccion, String email, String comentarios) 
			do {
				System.out.println("Que atributo quieres modificar? \n"
						+ "1. Nombre \n"
						+ "2. Apellido \n"
						+ "3. Direccion \n"
						+ "4. Email \n"
						+ "5. Comentarios \n"
						+ "0. Ninguno");
				
				switch(opcionModificar) {
					case 1:
						System.out.println("Introduce el cliente que quieres modificar: \n"
								+ "Nombre: ");
						nuevoNombre = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setNombre(nuevoNombre);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 2:
						System.out.println("Apellido: ");
						nuevoApellido = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setApellido(nuevoApellido);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 3:
						System.out.println("Direccion: ");
						nuevoDireccion = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setDireccion(nuevoDireccion);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 4:
						System.out.println("Email: ");
						nuevoEmail = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setEmail(nuevoEmail);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 5:
						System.out.println("Comentarios: ");
						nuevoComentarios = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setComentarios(nuevoComentarios);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					default: 
						System.out.println("Error, elija entre 1-5");
				
				}
				
			}while(opcionModificar != 0);
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	
		
		
		
	}
	
	public static void verClientes(int optionVer) {
		/*
		 * La opción de consulta de un cliente o de todos los clientes, debe nombrar el método
	verClientes(param1) donde se indicará un parámetro que permitirá mostrar un cliente o todos.
	
	En caso de desear visualizar un único cliente,
	 deberá pedir al usuario el nombre o id del cliente
	que quiere que mostramos por pantalla, si el cliente está en nuestra aplicación, 
	le mostraremos toda la
	información incluyendo los presupuestos vinculados, 
	
	si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	En caso de desear visualizar todos los clientes, muestre todos los atributos de cada cliente.
		 */
		
		String verNombre = "";
		String verApellido = "";
		int verId = 0;
		int verPosicion = 0;
		
		switch(optionVer) {
		case 1:

			System.out.println("Introduce el nombre del cliente que quieres ver: \n"
					+ "Nombre: ");
			verNombre = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el apellido: ");
			verApellido = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el id: ");
			verId = sc.nextInt();
			sc.nextLine();
			

			verPosicion = obtenerPosicion(verNombre, verApellido, verId);
			
			if(verPosicion != -1) {
				System.out.println(clientes.get(verPosicion).toString());
				
			}else {
				System.out.println("El cliente no esta dentro de la aplicacion");
			}
			
			break;
			
		case 2:
			System.out.println(clientes);
			break;
			
		default:
			System.out.println("Erorr, no has elejido entre 1-2");
		}
		
			
	}
	
	public static void crearPresupuesto() {
		/*
		 * La opción de generar presupuesto, debe nombrar el método crearPresupuesto(), y éste deberá
	pedir al usuario el nombre o el id del cliente para poder comprobar si el cliente está dentro de
	el array. Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes, almacenar el objeto correspondientemente vinculado al cliente y obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
		 */
		String presupuestoNombre = "";
		String presupuestoApellido = "";
		int presupuestoId = 0;
		int posicionPresupuesto = 0;
		
	
		System.out.println("Introduce el nombre del cliente para crear presupuesto: \n"
				+ "Nombre: ");
		presupuestoNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		presupuestoApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		presupuestoId = sc.nextInt();
		sc.nextLine();
		
		
		posicionPresupuesto = obtenerPosicion(presupuestoNombre, presupuestoApellido, presupuestoId);
		
		if(posicionPresupuesto != -1) {
			/*Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes,
	obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	*/
			String concepto = "";
			double valor =0d;
			int iva = 0;
			
			System.out.println("Antes: " + clientes.get(posicionPresupuesto).toString());
			
			System.out.println("Introduce los datos para generar el presupuesto: \n"
					+ "Concepto: ");
			concepto = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Apellido: ");
			valor = sc.nextDouble();
			sc.nextLine();
			
			System.out.println("Direccion: ");
			iva = sc.nextInt();
			sc.nextLine();
			
			Presupuesto nuevoPresupuesto = new Presupuesto(concepto, valor, iva);
			
			clientes.get(posicionPresupuesto).agregarPresupuesto(nuevoPresupuesto);
			
			System.out.println("Despues: " + clientes.get(posicionPresupuesto).toString());
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
		
	}
	
	public static int obtenerPosicion(String nombre, String apellido, int identificador) {
		int i =0;
		int posicion = -1;
		boolean encontrado = false;
		
		while(i< clientes.size() && encontrado == false) {
			
			if(clientes.get(i).getNombre().equalsIgnoreCase(nombre) && clientes.get(i).getApellido().equalsIgnoreCase(apellido) || 
					clientes.get(i).getId() == identificador) {
				encontrado = true;
				posicion = i;
			}
			i++;
		}
		return posicion;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:02.229
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:02.230
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-28 12:37:02.245
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;
import java.util.Scanner;

public class Examen_Final_Leidy_Zhang {
	/*
	 * Nos piden elaborar un CRM de gestión de clientes y que tendrá que gestionar a través de un
	menú de opciones las altas de un cliente, consulta de un cliente o todos los clientes, generar presupuesto,
	modificación de un cliente y eliminación de un cliente.
	*/
	static Scanner sc = new Scanner(System.in);
	static ArrayList<Cliente> clientes = new ArrayList<Cliente>();
	static Cliente nuevo = new CLi
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 1. Se debe definir un cliente predefinido con los diferentes datos aportados estáticamente y
correspondientes a cada uno de los atributos.
2. Defina un nuevo e-mail por el usuario creado.
3. Genere un presupuesto con el concepto “170h. Elaboración de una API”, precio 2410 € y
con un iva 21%.
4. Genere un presupuesto con el concepto “250h. Diseño imagen corporativa”, precio
3110€ y con un iva 21%.
5. Muestre la info del cliente que ha creado mediante el método consulta de un cliente.
6. Debe definirse otro cliente con los diferentes datos aportados por el usuario y
correspondientes a cada uno de los atributos.
7. Muestre la información de todos los clientes existentes.
8. Elimine el último cliente creado.
		 */
		
		

		int opcion = 0;
		int optionVer = 0;
		
		do {
			System.out.println("Menu \n"
					+ "0. Salir de la aplicacion \n"
					+ "1. Dar de alta un cliente \n"
					+ "2. Eliminar cliente \n"
					+ "3. Modificar un cliente \n"
					+ "4. Consultar datos de un cliente o todos \n"
					+ "5. Generar presupuesto");
			
			opcion = sc.nextInt();
			sc.nextLine();
			
		switch(opcion) {
		
			case 1:
				crearCliente();
				break;	
			case 2:
				eliminarCliente();
				break;
			case 3:
				modificarCliente();
				break;
			case 4:
				System.out.println("Quiere ver: \n"
						+ "1. Un solo cliente \n"
						+ "2. Todos los clientes");
				
				optionVer = sc.nextInt();
				sc.nextLine();
				
				verClientes(optionVer);
				
				break;
			case 5:
				crearPresupuesto();
				break;	
			default:
				System.out.println("Error. Introduce una opcion entre 1-5");
		}

		}while(opcion !=0);
		
		System.out.println("Has salido de la aplicacion");
	}

	public static void crearCliente() {
		
		/*
		 * La opción alta de un cliente debe nombrar el método altaClient(), y éste a la vez deberá
	pedir al usuario que introduzca por pantalla los datos mencionados anteriormente (o deberá
	de recibir estos datos por parámetro), exceptuando el id que se tendrá que autogenerar utilizando
	Math. Una vez que haya pedido todos estos datos, debe instanciarse el objeto de la clase y
	añadirlo a un array de clientes.
		 */
		String nombre = "";
		String apellido = "";
		String direccion = "";
		String email = "";
		String comentarios = "";
		
	
		System.out.println("Introduce los datos del nuevo cliente: \n"
				+ "Nombre: ");
		nombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		apellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Direccion: ");
		direccion = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Email: ");
		email = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Comentarios: ");
		comentarios = sc.nextLine();
		sc.nextLine();
		
		Cliente nuevoCliente = new Cliente(nombre, apellido, direccion, email, comentarios);
		clientes.add(nuevoCliente);
		
		
	}
	
	public static void eliminarCliente() {
		/*
		 * La opción de eliminar un cliente debe nombrar el método darDeBaixaClient(), y éste deberá
		pedir al usuario el nombre o el id del cliente que quiere darse de baja y si el cliente está dentro de
		el array, lo eliminaremos y mostraremos un mensaje por pantalla informando al usuario que hemos eliminado
		el cliente. Si no hemos encontrado al cliente dentro del array, avisaremos al usuario diciendo que el cliente no
		estaba dentro de nuestra aplicación.
		 */
		
		String eliminarNombre = "";
		String eliminarApellido = "";
		int eliminarId = 0;
		int posicionEliminar = 0;
		
	
		System.out.println("Introduce el nombre del cliente que quieres eliminar: \n"
				+ "Nombre: ");
		eliminarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		eliminarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		eliminarId = sc.nextInt();
		sc.nextLine();
		
		
		posicionEliminar = obtenerPosicion(eliminarNombre, eliminarApellido, eliminarId);
		
		if(posicionEliminar != -1) {
			clientes.remove(posicionEliminar);
			System.out.println("El cliente se ha eliminado exitosamente");
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	}
	
	public static void modificarCliente() {
		/*
		 * La opción de modificar de un cliente, debe nombrar el método modificarClient(), y éste deberá
	pedir al usuario el nombre o el id del cliente que queremos modificar. Si lo tenemos en la aplicación, le
	preguntaremos si desea modificar cualquiera de los atributos, exceptuando el id. Haremos la modificación
	pertinente y avisaremos al usuario de que la modificación se ha realizado. En caso contrario, indicaremos en
	el usuario que no existe el cliente dentro de la aplicación.
		 */
		String modificarNombre = "";
		String modificarApellido = "";
		int modificarId = 0;
		int posicionModificar = 0;
		int opcionModificar = 0;
		
		String nuevoNombre = "";
		String nuevoApellido = "";
		String nuevoDireccion = "";
		String nuevoEmail = "";
		String nuevoComentarios = "";
		
	
		System.out.println("Introduce el cliente que quieres modificar: \n"
				+ "Nombre: ");
		modificarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		modificarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		modificarId = sc.nextInt();
		sc.nextLine();
		
		posicionModificar  = obtenerPosicion(modificarNombre, modificarApellido, modificarId);
		
		if(posicionModificar != -1) {
			//(String nombre, String apellido, String direccion, String email, String comentarios) 
			do {
				System.out.println("Que atributo quieres modificar? \n"
						+ "1. Nombre \n"
						+ "2. Apellido \n"
						+ "3. Direccion \n"
						+ "4. Email \n"
						+ "5. Comentarios \n"
						+ "0. Ninguno");
				
				switch(opcionModificar) {
					case 1:
						System.out.println("Introduce el cliente que quieres modificar: \n"
								+ "Nombre: ");
						nuevoNombre = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setNombre(nuevoNombre);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 2:
						System.out.println("Apellido: ");
						nuevoApellido = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setApellido(nuevoApellido);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 3:
						System.out.println("Direccion: ");
						nuevoDireccion = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setDireccion(nuevoDireccion);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 4:
						System.out.println("Email: ");
						nuevoEmail = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setEmail(nuevoEmail);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 5:
						System.out.println("Comentarios: ");
						nuevoComentarios = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setComentarios(nuevoComentarios);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					default: 
						System.out.println("Error, elija entre 1-5");
				
				}
				
			}while(opcionModificar != 0);
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	
		
		
		
	}
	
	public static void verClientes(int optionVer) {
		/*
		 * La opción de consulta de un cliente o de todos los clientes, debe nombrar el método
	verClientes(param1) donde se indicará un parámetro que permitirá mostrar un cliente o todos.
	
	En caso de desear visualizar un único cliente,
	 deberá pedir al usuario el nombre o id del cliente
	que quiere que mostramos por pantalla, si el cliente está en nuestra aplicación, 
	le mostraremos toda la
	información incluyendo los presupuestos vinculados, 
	
	si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	En caso de desear visualizar todos los clientes, muestre todos los atributos de cada cliente.
		 */
		
		String verNombre = "";
		String verApellido = "";
		int verId = 0;
		int verPosicion = 0;
		
		switch(optionVer) {
		case 1:

			System.out.println("Introduce el nombre del cliente que quieres ver: \n"
					+ "Nombre: ");
			verNombre = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el apellido: ");
			verApellido = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el id: ");
			verId = sc.nextInt();
			sc.nextLine();
			

			verPosicion = obtenerPosicion(verNombre, verApellido, verId);
			
			if(verPosicion != -1) {
				System.out.println(clientes.get(verPosicion).toString());
				
			}else {
				System.out.println("El cliente no esta dentro de la aplicacion");
			}
			
			break;
			
		case 2:
			System.out.println(clientes);
			break;
			
		default:
			System.out.println("Erorr, no has elejido entre 1-2");
		}
		
			
	}
	
	public static void crearPresupuesto() {
		/*
		 * La opción de generar presupuesto, debe nombrar el método crearPresupuesto(), y éste deberá
	pedir al usuario el nombre o el id del cliente para poder comprobar si el cliente está dentro de
	el array. Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes, almacenar el objeto correspondientemente vinculado al cliente y obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
		 */
		String presupuestoNombre = "";
		String presupuestoApellido = "";
		int presupuestoId = 0;
		int posicionPresupuesto = 0;
		
	
		System.out.println("Introduce el nombre del cliente para crear presupuesto: \n"
				+ "Nombre: ");
		presupuestoNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		presupuestoApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		presupuestoId = sc.nextInt();
		sc.nextLine();
		
		
		posicionPresupuesto = obtenerPosicion(presupuestoNombre, presupuestoApellido, presupuestoId);
		
		if(posicionPresupuesto != -1) {
			/*Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes,
	obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	*/
			String concepto = "";
			double valor =0d;
			int iva = 0;
			
			System.out.println("Antes: " + clientes.get(posicionPresupuesto).toString());
			
			System.out.println("Introduce los datos para generar el presupuesto: \n"
					+ "Concepto: ");
			concepto = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Apellido: ");
			valor = sc.nextDouble();
			sc.nextLine();
			
			System.out.println("Direccion: ");
			iva = sc.nextInt();
			sc.nextLine();
			
			Presupuesto nuevoPresupuesto = new Presupuesto(concepto, valor, iva);
			
			clientes.get(posicionPresupuesto).agregarPresupuesto(nuevoPresupuesto);
			
			System.out.println("Despues: " + clientes.get(posicionPresupuesto).toString());
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
		
	}
	
	public static int obtenerPosicion(String nombre, String apellido, int identificador) {
		int i =0;
		int posicion = -1;
		boolean encontrado = false;
		
		while(i< clientes.size() && encontrado == false) {
			
			if(clientes.get(i).getNombre().equalsIgnoreCase(nombre) && clientes.get(i).getApellido().equalsIgnoreCase(apellido) || 
					clientes.get(i).getId() == identificador) {
				encontrado = true;
				posicion = i;
			}
			i++;
		}
		return posicion;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:02.246
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:02.247
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-28 12:37:03.030
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;
import java.util.Scanner;

public class Examen_Final_Leidy_Zhang {
	/*
	 * Nos piden elaborar un CRM de gestión de clientes y que tendrá que gestionar a través de un
	menú de opciones las altas de un cliente, consulta de un cliente o todos los clientes, generar presupuesto,
	modificación de un cliente y eliminación de un cliente.
	*/
	static Scanner sc = new Scanner(System.in);
	static ArrayList<Cliente> clientes = new ArrayList<Cliente>();
	static Cliente nuevo = new CLine
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 1. Se debe definir un cliente predefinido con los diferentes datos aportados estáticamente y
correspondientes a cada uno de los atributos.
2. Defina un nuevo e-mail por el usuario creado.
3. Genere un presupuesto con el concepto “170h. Elaboración de una API”, precio 2410 € y
con un iva 21%.
4. Genere un presupuesto con el concepto “250h. Diseño imagen corporativa”, precio
3110€ y con un iva 21%.
5. Muestre la info del cliente que ha creado mediante el método consulta de un cliente.
6. Debe definirse otro cliente con los diferentes datos aportados por el usuario y
correspondientes a cada uno de los atributos.
7. Muestre la información de todos los clientes existentes.
8. Elimine el último cliente creado.
		 */
		
		

		int opcion = 0;
		int optionVer = 0;
		
		do {
			System.out.println("Menu \n"
					+ "0. Salir de la aplicacion \n"
					+ "1. Dar de alta un cliente \n"
					+ "2. Eliminar cliente \n"
					+ "3. Modificar un cliente \n"
					+ "4. Consultar datos de un cliente o todos \n"
					+ "5. Generar presupuesto");
			
			opcion = sc.nextInt();
			sc.nextLine();
			
		switch(opcion) {
		
			case 1:
				crearCliente();
				break;	
			case 2:
				eliminarCliente();
				break;
			case 3:
				modificarCliente();
				break;
			case 4:
				System.out.println("Quiere ver: \n"
						+ "1. Un solo cliente \n"
						+ "2. Todos los clientes");
				
				optionVer = sc.nextInt();
				sc.nextLine();
				
				verClientes(optionVer);
				
				break;
			case 5:
				crearPresupuesto();
				break;	
			default:
				System.out.println("Error. Introduce una opcion entre 1-5");
		}

		}while(opcion !=0);
		
		System.out.println("Has salido de la aplicacion");
	}

	public static void crearCliente() {
		
		/*
		 * La opción alta de un cliente debe nombrar el método altaClient(), y éste a la vez deberá
	pedir al usuario que introduzca por pantalla los datos mencionados anteriormente (o deberá
	de recibir estos datos por parámetro), exceptuando el id que se tendrá que autogenerar utilizando
	Math. Una vez que haya pedido todos estos datos, debe instanciarse el objeto de la clase y
	añadirlo a un array de clientes.
		 */
		String nombre = "";
		String apellido = "";
		String direccion = "";
		String email = "";
		String comentarios = "";
		
	
		System.out.println("Introduce los datos del nuevo cliente: \n"
				+ "Nombre: ");
		nombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		apellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Direccion: ");
		direccion = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Email: ");
		email = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Comentarios: ");
		comentarios = sc.nextLine();
		sc.nextLine();
		
		Cliente nuevoCliente = new Cliente(nombre, apellido, direccion, email, comentarios);
		clientes.add(nuevoCliente);
		
		
	}
	
	public static void eliminarCliente() {
		/*
		 * La opción de eliminar un cliente debe nombrar el método darDeBaixaClient(), y éste deberá
		pedir al usuario el nombre o el id del cliente que quiere darse de baja y si el cliente está dentro de
		el array, lo eliminaremos y mostraremos un mensaje por pantalla informando al usuario que hemos eliminado
		el cliente. Si no hemos encontrado al cliente dentro del array, avisaremos al usuario diciendo que el cliente no
		estaba dentro de nuestra aplicación.
		 */
		
		String eliminarNombre = "";
		String eliminarApellido = "";
		int eliminarId = 0;
		int posicionEliminar = 0;
		
	
		System.out.println("Introduce el nombre del cliente que quieres eliminar: \n"
				+ "Nombre: ");
		eliminarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		eliminarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		eliminarId = sc.nextInt();
		sc.nextLine();
		
		
		posicionEliminar = obtenerPosicion(eliminarNombre, eliminarApellido, eliminarId);
		
		if(posicionEliminar != -1) {
			clientes.remove(posicionEliminar);
			System.out.println("El cliente se ha eliminado exitosamente");
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	}
	
	public static void modificarCliente() {
		/*
		 * La opción de modificar de un cliente, debe nombrar el método modificarClient(), y éste deberá
	pedir al usuario el nombre o el id del cliente que queremos modificar. Si lo tenemos en la aplicación, le
	preguntaremos si desea modificar cualquiera de los atributos, exceptuando el id. Haremos la modificación
	pertinente y avisaremos al usuario de que la modificación se ha realizado. En caso contrario, indicaremos en
	el usuario que no existe el cliente dentro de la aplicación.
		 */
		String modificarNombre = "";
		String modificarApellido = "";
		int modificarId = 0;
		int posicionModificar = 0;
		int opcionModificar = 0;
		
		String nuevoNombre = "";
		String nuevoApellido = "";
		String nuevoDireccion = "";
		String nuevoEmail = "";
		String nuevoComentarios = "";
		
	
		System.out.println("Introduce el cliente que quieres modificar: \n"
				+ "Nombre: ");
		modificarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		modificarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		modificarId = sc.nextInt();
		sc.nextLine();
		
		posicionModificar  = obtenerPosicion(modificarNombre, modificarApellido, modificarId);
		
		if(posicionModificar != -1) {
			//(String nombre, String apellido, String direccion, String email, String comentarios) 
			do {
				System.out.println("Que atributo quieres modificar? \n"
						+ "1. Nombre \n"
						+ "2. Apellido \n"
						+ "3. Direccion \n"
						+ "4. Email \n"
						+ "5. Comentarios \n"
						+ "0. Ninguno");
				
				switch(opcionModificar) {
					case 1:
						System.out.println("Introduce el cliente que quieres modificar: \n"
								+ "Nombre: ");
						nuevoNombre = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setNombre(nuevoNombre);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 2:
						System.out.println("Apellido: ");
						nuevoApellido = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setApellido(nuevoApellido);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 3:
						System.out.println("Direccion: ");
						nuevoDireccion = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setDireccion(nuevoDireccion);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 4:
						System.out.println("Email: ");
						nuevoEmail = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setEmail(nuevoEmail);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 5:
						System.out.println("Comentarios: ");
						nuevoComentarios = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setComentarios(nuevoComentarios);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					default: 
						System.out.println("Error, elija entre 1-5");
				
				}
				
			}while(opcionModificar != 0);
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	
		
		
		
	}
	
	public static void verClientes(int optionVer) {
		/*
		 * La opción de consulta de un cliente o de todos los clientes, debe nombrar el método
	verClientes(param1) donde se indicará un parámetro que permitirá mostrar un cliente o todos.
	
	En caso de desear visualizar un único cliente,
	 deberá pedir al usuario el nombre o id del cliente
	que quiere que mostramos por pantalla, si el cliente está en nuestra aplicación, 
	le mostraremos toda la
	información incluyendo los presupuestos vinculados, 
	
	si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	En caso de desear visualizar todos los clientes, muestre todos los atributos de cada cliente.
		 */
		
		String verNombre = "";
		String verApellido = "";
		int verId = 0;
		int verPosicion = 0;
		
		switch(optionVer) {
		case 1:

			System.out.println("Introduce el nombre del cliente que quieres ver: \n"
					+ "Nombre: ");
			verNombre = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el apellido: ");
			verApellido = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el id: ");
			verId = sc.nextInt();
			sc.nextLine();
			

			verPosicion = obtenerPosicion(verNombre, verApellido, verId);
			
			if(verPosicion != -1) {
				System.out.println(clientes.get(verPosicion).toString());
				
			}else {
				System.out.println("El cliente no esta dentro de la aplicacion");
			}
			
			break;
			
		case 2:
			System.out.println(clientes);
			break;
			
		default:
			System.out.println("Erorr, no has elejido entre 1-2");
		}
		
			
	}
	
	public static void crearPresupuesto() {
		/*
		 * La opción de generar presupuesto, debe nombrar el método crearPresupuesto(), y éste deberá
	pedir al usuario el nombre o el id del cliente para poder comprobar si el cliente está dentro de
	el array. Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes, almacenar el objeto correspondientemente vinculado al cliente y obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
		 */
		String presupuestoNombre = "";
		String presupuestoApellido = "";
		int presupuestoId = 0;
		int posicionPresupuesto = 0;
		
	
		System.out.println("Introduce el nombre del cliente para crear presupuesto: \n"
				+ "Nombre: ");
		presupuestoNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		presupuestoApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		presupuestoId = sc.nextInt();
		sc.nextLine();
		
		
		posicionPresupuesto = obtenerPosicion(presupuestoNombre, presupuestoApellido, presupuestoId);
		
		if(posicionPresupuesto != -1) {
			/*Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes,
	obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	*/
			String concepto = "";
			double valor =0d;
			int iva = 0;
			
			System.out.println("Antes: " + clientes.get(posicionPresupuesto).toString());
			
			System.out.println("Introduce los datos para generar el presupuesto: \n"
					+ "Concepto: ");
			concepto = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Apellido: ");
			valor = sc.nextDouble();
			sc.nextLine();
			
			System.out.println("Direccion: ");
			iva = sc.nextInt();
			sc.nextLine();
			
			Presupuesto nuevoPresupuesto = new Presupuesto(concepto, valor, iva);
			
			clientes.get(posicionPresupuesto).agregarPresupuesto(nuevoPresupuesto);
			
			System.out.println("Despues: " + clientes.get(posicionPresupuesto).toString());
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
		
	}
	
	public static int obtenerPosicion(String nombre, String apellido, int identificador) {
		int i =0;
		int posicion = -1;
		boolean encontrado = false;
		
		while(i< clientes.size() && encontrado == false) {
			
			if(clientes.get(i).getNombre().equalsIgnoreCase(nombre) && clientes.get(i).getApellido().equalsIgnoreCase(apellido) || 
					clientes.get(i).getId() == identificador) {
				encontrado = true;
				posicion = i;
			}
			i++;
		}
		return posicion;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:03.031
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:03.032
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-28 12:37:04.576
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;
import java.util.Scanner;

public class Examen_Final_Leidy_Zhang {
	/*
	 * Nos piden elaborar un CRM de gestión de clientes y que tendrá que gestionar a través de un
	menú de opciones las altas de un cliente, consulta de un cliente o todos los clientes, generar presupuesto,
	modificación de un cliente y eliminación de un cliente.
	*/
	static Scanner sc = new Scanner(System.in);
	static ArrayList<Cliente> clientes = new ArrayList<Cliente>();
	static Cliente nuevo = new C
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 1. Se debe definir un cliente predefinido con los diferentes datos aportados estáticamente y
correspondientes a cada uno de los atributos.
2. Defina un nuevo e-mail por el usuario creado.
3. Genere un presupuesto con el concepto “170h. Elaboración de una API”, precio 2410 € y
con un iva 21%.
4. Genere un presupuesto con el concepto “250h. Diseño imagen corporativa”, precio
3110€ y con un iva 21%.
5. Muestre la info del cliente que ha creado mediante el método consulta de un cliente.
6. Debe definirse otro cliente con los diferentes datos aportados por el usuario y
correspondientes a cada uno de los atributos.
7. Muestre la información de todos los clientes existentes.
8. Elimine el último cliente creado.
		 */
		
		

		int opcion = 0;
		int optionVer = 0;
		
		do {
			System.out.println("Menu \n"
					+ "0. Salir de la aplicacion \n"
					+ "1. Dar de alta un cliente \n"
					+ "2. Eliminar cliente \n"
					+ "3. Modificar un cliente \n"
					+ "4. Consultar datos de un cliente o todos \n"
					+ "5. Generar presupuesto");
			
			opcion = sc.nextInt();
			sc.nextLine();
			
		switch(opcion) {
		
			case 1:
				crearCliente();
				break;	
			case 2:
				eliminarCliente();
				break;
			case 3:
				modificarCliente();
				break;
			case 4:
				System.out.println("Quiere ver: \n"
						+ "1. Un solo cliente \n"
						+ "2. Todos los clientes");
				
				optionVer = sc.nextInt();
				sc.nextLine();
				
				verClientes(optionVer);
				
				break;
			case 5:
				crearPresupuesto();
				break;	
			default:
				System.out.println("Error. Introduce una opcion entre 1-5");
		}

		}while(opcion !=0);
		
		System.out.println("Has salido de la aplicacion");
	}

	public static void crearCliente() {
		
		/*
		 * La opción alta de un cliente debe nombrar el método altaClient(), y éste a la vez deberá
	pedir al usuario que introduzca por pantalla los datos mencionados anteriormente (o deberá
	de recibir estos datos por parámetro), exceptuando el id que se tendrá que autogenerar utilizando
	Math. Una vez que haya pedido todos estos datos, debe instanciarse el objeto de la clase y
	añadirlo a un array de clientes.
		 */
		String nombre = "";
		String apellido = "";
		String direccion = "";
		String email = "";
		String comentarios = "";
		
	
		System.out.println("Introduce los datos del nuevo cliente: \n"
				+ "Nombre: ");
		nombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		apellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Direccion: ");
		direccion = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Email: ");
		email = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Comentarios: ");
		comentarios = sc.nextLine();
		sc.nextLine();
		
		Cliente nuevoCliente = new Cliente(nombre, apellido, direccion, email, comentarios);
		clientes.add(nuevoCliente);
		
		
	}
	
	public static void eliminarCliente() {
		/*
		 * La opción de eliminar un cliente debe nombrar el método darDeBaixaClient(), y éste deberá
		pedir al usuario el nombre o el id del cliente que quiere darse de baja y si el cliente está dentro de
		el array, lo eliminaremos y mostraremos un mensaje por pantalla informando al usuario que hemos eliminado
		el cliente. Si no hemos encontrado al cliente dentro del array, avisaremos al usuario diciendo que el cliente no
		estaba dentro de nuestra aplicación.
		 */
		
		String eliminarNombre = "";
		String eliminarApellido = "";
		int eliminarId = 0;
		int posicionEliminar = 0;
		
	
		System.out.println("Introduce el nombre del cliente que quieres eliminar: \n"
				+ "Nombre: ");
		eliminarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		eliminarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		eliminarId = sc.nextInt();
		sc.nextLine();
		
		
		posicionEliminar = obtenerPosicion(eliminarNombre, eliminarApellido, eliminarId);
		
		if(posicionEliminar != -1) {
			clientes.remove(posicionEliminar);
			System.out.println("El cliente se ha eliminado exitosamente");
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	}
	
	public static void modificarCliente() {
		/*
		 * La opción de modificar de un cliente, debe nombrar el método modificarClient(), y éste deberá
	pedir al usuario el nombre o el id del cliente que queremos modificar. Si lo tenemos en la aplicación, le
	preguntaremos si desea modificar cualquiera de los atributos, exceptuando el id. Haremos la modificación
	pertinente y avisaremos al usuario de que la modificación se ha realizado. En caso contrario, indicaremos en
	el usuario que no existe el cliente dentro de la aplicación.
		 */
		String modificarNombre = "";
		String modificarApellido = "";
		int modificarId = 0;
		int posicionModificar = 0;
		int opcionModificar = 0;
		
		String nuevoNombre = "";
		String nuevoApellido = "";
		String nuevoDireccion = "";
		String nuevoEmail = "";
		String nuevoComentarios = "";
		
	
		System.out.println("Introduce el cliente que quieres modificar: \n"
				+ "Nombre: ");
		modificarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		modificarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		modificarId = sc.nextInt();
		sc.nextLine();
		
		posicionModificar  = obtenerPosicion(modificarNombre, modificarApellido, modificarId);
		
		if(posicionModificar != -1) {
			//(String nombre, String apellido, String direccion, String email, String comentarios) 
			do {
				System.out.println("Que atributo quieres modificar? \n"
						+ "1. Nombre \n"
						+ "2. Apellido \n"
						+ "3. Direccion \n"
						+ "4. Email \n"
						+ "5. Comentarios \n"
						+ "0. Ninguno");
				
				switch(opcionModificar) {
					case 1:
						System.out.println("Introduce el cliente que quieres modificar: \n"
								+ "Nombre: ");
						nuevoNombre = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setNombre(nuevoNombre);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 2:
						System.out.println("Apellido: ");
						nuevoApellido = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setApellido(nuevoApellido);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 3:
						System.out.println("Direccion: ");
						nuevoDireccion = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setDireccion(nuevoDireccion);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 4:
						System.out.println("Email: ");
						nuevoEmail = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setEmail(nuevoEmail);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 5:
						System.out.println("Comentarios: ");
						nuevoComentarios = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setComentarios(nuevoComentarios);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					default: 
						System.out.println("Error, elija entre 1-5");
				
				}
				
			}while(opcionModificar != 0);
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	
		
		
		
	}
	
	public static void verClientes(int optionVer) {
		/*
		 * La opción de consulta de un cliente o de todos los clientes, debe nombrar el método
	verClientes(param1) donde se indicará un parámetro que permitirá mostrar un cliente o todos.
	
	En caso de desear visualizar un único cliente,
	 deberá pedir al usuario el nombre o id del cliente
	que quiere que mostramos por pantalla, si el cliente está en nuestra aplicación, 
	le mostraremos toda la
	información incluyendo los presupuestos vinculados, 
	
	si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	En caso de desear visualizar todos los clientes, muestre todos los atributos de cada cliente.
		 */
		
		String verNombre = "";
		String verApellido = "";
		int verId = 0;
		int verPosicion = 0;
		
		switch(optionVer) {
		case 1:

			System.out.println("Introduce el nombre del cliente que quieres ver: \n"
					+ "Nombre: ");
			verNombre = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el apellido: ");
			verApellido = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el id: ");
			verId = sc.nextInt();
			sc.nextLine();
			

			verPosicion = obtenerPosicion(verNombre, verApellido, verId);
			
			if(verPosicion != -1) {
				System.out.println(clientes.get(verPosicion).toString());
				
			}else {
				System.out.println("El cliente no esta dentro de la aplicacion");
			}
			
			break;
			
		case 2:
			System.out.println(clientes);
			break;
			
		default:
			System.out.println("Erorr, no has elejido entre 1-2");
		}
		
			
	}
	
	public static void crearPresupuesto() {
		/*
		 * La opción de generar presupuesto, debe nombrar el método crearPresupuesto(), y éste deberá
	pedir al usuario el nombre o el id del cliente para poder comprobar si el cliente está dentro de
	el array. Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes, almacenar el objeto correspondientemente vinculado al cliente y obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
		 */
		String presupuestoNombre = "";
		String presupuestoApellido = "";
		int presupuestoId = 0;
		int posicionPresupuesto = 0;
		
	
		System.out.println("Introduce el nombre del cliente para crear presupuesto: \n"
				+ "Nombre: ");
		presupuestoNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		presupuestoApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		presupuestoId = sc.nextInt();
		sc.nextLine();
		
		
		posicionPresupuesto = obtenerPosicion(presupuestoNombre, presupuestoApellido, presupuestoId);
		
		if(posicionPresupuesto != -1) {
			/*Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes,
	obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	*/
			String concepto = "";
			double valor =0d;
			int iva = 0;
			
			System.out.println("Antes: " + clientes.get(posicionPresupuesto).toString());
			
			System.out.println("Introduce los datos para generar el presupuesto: \n"
					+ "Concepto: ");
			concepto = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Apellido: ");
			valor = sc.nextDouble();
			sc.nextLine();
			
			System.out.println("Direccion: ");
			iva = sc.nextInt();
			sc.nextLine();
			
			Presupuesto nuevoPresupuesto = new Presupuesto(concepto, valor, iva);
			
			clientes.get(posicionPresupuesto).agregarPresupuesto(nuevoPresupuesto);
			
			System.out.println("Despues: " + clientes.get(posicionPresupuesto).toString());
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
		
	}
	
	public static int obtenerPosicion(String nombre, String apellido, int identificador) {
		int i =0;
		int posicion = -1;
		boolean encontrado = false;
		
		while(i< clientes.size() && encontrado == false) {
			
			if(clientes.get(i).getNombre().equalsIgnoreCase(nombre) && clientes.get(i).getApellido().equalsIgnoreCase(apellido) || 
					clientes.get(i).getId() == identificador) {
				encontrado = true;
				posicion = i;
			}
			i++;
		}
		return posicion;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:04.578
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:04.579
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-28 12:37:05.475
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;
import java.util.Scanner;

public class Examen_Final_Leidy_Zhang {
	/*
	 * Nos piden elaborar un CRM de gestión de clientes y que tendrá que gestionar a través de un
	menú de opciones las altas de un cliente, consulta de un cliente o todos los clientes, generar presupuesto,
	modificación de un cliente y eliminación de un cliente.
	*/
	static Scanner sc = new Scanner(System.in);
	static ArrayList<Cliente> clientes = new ArrayList<Cliente>();
	static Cliente nuevo = new Cli
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 1. Se debe definir un cliente predefinido con los diferentes datos aportados estáticamente y
correspondientes a cada uno de los atributos.
2. Defina un nuevo e-mail por el usuario creado.
3. Genere un presupuesto con el concepto “170h. Elaboración de una API”, precio 2410 € y
con un iva 21%.
4. Genere un presupuesto con el concepto “250h. Diseño imagen corporativa”, precio
3110€ y con un iva 21%.
5. Muestre la info del cliente que ha creado mediante el método consulta de un cliente.
6. Debe definirse otro cliente con los diferentes datos aportados por el usuario y
correspondientes a cada uno de los atributos.
7. Muestre la información de todos los clientes existentes.
8. Elimine el último cliente creado.
		 */
		
		

		int opcion = 0;
		int optionVer = 0;
		
		do {
			System.out.println("Menu \n"
					+ "0. Salir de la aplicacion \n"
					+ "1. Dar de alta un cliente \n"
					+ "2. Eliminar cliente \n"
					+ "3. Modificar un cliente \n"
					+ "4. Consultar datos de un cliente o todos \n"
					+ "5. Generar presupuesto");
			
			opcion = sc.nextInt();
			sc.nextLine();
			
		switch(opcion) {
		
			case 1:
				crearCliente();
				break;	
			case 2:
				eliminarCliente();
				break;
			case 3:
				modificarCliente();
				break;
			case 4:
				System.out.println("Quiere ver: \n"
						+ "1. Un solo cliente \n"
						+ "2. Todos los clientes");
				
				optionVer = sc.nextInt();
				sc.nextLine();
				
				verClientes(optionVer);
				
				break;
			case 5:
				crearPresupuesto();
				break;	
			default:
				System.out.println("Error. Introduce una opcion entre 1-5");
		}

		}while(opcion !=0);
		
		System.out.println("Has salido de la aplicacion");
	}

	public static void crearCliente() {
		
		/*
		 * La opción alta de un cliente debe nombrar el método altaClient(), y éste a la vez deberá
	pedir al usuario que introduzca por pantalla los datos mencionados anteriormente (o deberá
	de recibir estos datos por parámetro), exceptuando el id que se tendrá que autogenerar utilizando
	Math. Una vez que haya pedido todos estos datos, debe instanciarse el objeto de la clase y
	añadirlo a un array de clientes.
		 */
		String nombre = "";
		String apellido = "";
		String direccion = "";
		String email = "";
		String comentarios = "";
		
	
		System.out.println("Introduce los datos del nuevo cliente: \n"
				+ "Nombre: ");
		nombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		apellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Direccion: ");
		direccion = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Email: ");
		email = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Comentarios: ");
		comentarios = sc.nextLine();
		sc.nextLine();
		
		Cliente nuevoCliente = new Cliente(nombre, apellido, direccion, email, comentarios);
		clientes.add(nuevoCliente);
		
		
	}
	
	public static void eliminarCliente() {
		/*
		 * La opción de eliminar un cliente debe nombrar el método darDeBaixaClient(), y éste deberá
		pedir al usuario el nombre o el id del cliente que quiere darse de baja y si el cliente está dentro de
		el array, lo eliminaremos y mostraremos un mensaje por pantalla informando al usuario que hemos eliminado
		el cliente. Si no hemos encontrado al cliente dentro del array, avisaremos al usuario diciendo que el cliente no
		estaba dentro de nuestra aplicación.
		 */
		
		String eliminarNombre = "";
		String eliminarApellido = "";
		int eliminarId = 0;
		int posicionEliminar = 0;
		
	
		System.out.println("Introduce el nombre del cliente que quieres eliminar: \n"
				+ "Nombre: ");
		eliminarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		eliminarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		eliminarId = sc.nextInt();
		sc.nextLine();
		
		
		posicionEliminar = obtenerPosicion(eliminarNombre, eliminarApellido, eliminarId);
		
		if(posicionEliminar != -1) {
			clientes.remove(posicionEliminar);
			System.out.println("El cliente se ha eliminado exitosamente");
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	}
	
	public static void modificarCliente() {
		/*
		 * La opción de modificar de un cliente, debe nombrar el método modificarClient(), y éste deberá
	pedir al usuario el nombre o el id del cliente que queremos modificar. Si lo tenemos en la aplicación, le
	preguntaremos si desea modificar cualquiera de los atributos, exceptuando el id. Haremos la modificación
	pertinente y avisaremos al usuario de que la modificación se ha realizado. En caso contrario, indicaremos en
	el usuario que no existe el cliente dentro de la aplicación.
		 */
		String modificarNombre = "";
		String modificarApellido = "";
		int modificarId = 0;
		int posicionModificar = 0;
		int opcionModificar = 0;
		
		String nuevoNombre = "";
		String nuevoApellido = "";
		String nuevoDireccion = "";
		String nuevoEmail = "";
		String nuevoComentarios = "";
		
	
		System.out.println("Introduce el cliente que quieres modificar: \n"
				+ "Nombre: ");
		modificarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		modificarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		modificarId = sc.nextInt();
		sc.nextLine();
		
		posicionModificar  = obtenerPosicion(modificarNombre, modificarApellido, modificarId);
		
		if(posicionModificar != -1) {
			//(String nombre, String apellido, String direccion, String email, String comentarios) 
			do {
				System.out.println("Que atributo quieres modificar? \n"
						+ "1. Nombre \n"
						+ "2. Apellido \n"
						+ "3. Direccion \n"
						+ "4. Email \n"
						+ "5. Comentarios \n"
						+ "0. Ninguno");
				
				switch(opcionModificar) {
					case 1:
						System.out.println("Introduce el cliente que quieres modificar: \n"
								+ "Nombre: ");
						nuevoNombre = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setNombre(nuevoNombre);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 2:
						System.out.println("Apellido: ");
						nuevoApellido = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setApellido(nuevoApellido);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 3:
						System.out.println("Direccion: ");
						nuevoDireccion = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setDireccion(nuevoDireccion);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 4:
						System.out.println("Email: ");
						nuevoEmail = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setEmail(nuevoEmail);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 5:
						System.out.println("Comentarios: ");
						nuevoComentarios = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setComentarios(nuevoComentarios);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					default: 
						System.out.println("Error, elija entre 1-5");
				
				}
				
			}while(opcionModificar != 0);
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	
		
		
		
	}
	
	public static void verClientes(int optionVer) {
		/*
		 * La opción de consulta de un cliente o de todos los clientes, debe nombrar el método
	verClientes(param1) donde se indicará un parámetro que permitirá mostrar un cliente o todos.
	
	En caso de desear visualizar un único cliente,
	 deberá pedir al usuario el nombre o id del cliente
	que quiere que mostramos por pantalla, si el cliente está en nuestra aplicación, 
	le mostraremos toda la
	información incluyendo los presupuestos vinculados, 
	
	si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	En caso de desear visualizar todos los clientes, muestre todos los atributos de cada cliente.
		 */
		
		String verNombre = "";
		String verApellido = "";
		int verId = 0;
		int verPosicion = 0;
		
		switch(optionVer) {
		case 1:

			System.out.println("Introduce el nombre del cliente que quieres ver: \n"
					+ "Nombre: ");
			verNombre = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el apellido: ");
			verApellido = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el id: ");
			verId = sc.nextInt();
			sc.nextLine();
			

			verPosicion = obtenerPosicion(verNombre, verApellido, verId);
			
			if(verPosicion != -1) {
				System.out.println(clientes.get(verPosicion).toString());
				
			}else {
				System.out.println("El cliente no esta dentro de la aplicacion");
			}
			
			break;
			
		case 2:
			System.out.println(clientes);
			break;
			
		default:
			System.out.println("Erorr, no has elejido entre 1-2");
		}
		
			
	}
	
	public static void crearPresupuesto() {
		/*
		 * La opción de generar presupuesto, debe nombrar el método crearPresupuesto(), y éste deberá
	pedir al usuario el nombre o el id del cliente para poder comprobar si el cliente está dentro de
	el array. Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes, almacenar el objeto correspondientemente vinculado al cliente y obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
		 */
		String presupuestoNombre = "";
		String presupuestoApellido = "";
		int presupuestoId = 0;
		int posicionPresupuesto = 0;
		
	
		System.out.println("Introduce el nombre del cliente para crear presupuesto: \n"
				+ "Nombre: ");
		presupuestoNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		presupuestoApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		presupuestoId = sc.nextInt();
		sc.nextLine();
		
		
		posicionPresupuesto = obtenerPosicion(presupuestoNombre, presupuestoApellido, presupuestoId);
		
		if(posicionPresupuesto != -1) {
			/*Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes,
	obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	*/
			String concepto = "";
			double valor =0d;
			int iva = 0;
			
			System.out.println("Antes: " + clientes.get(posicionPresupuesto).toString());
			
			System.out.println("Introduce los datos para generar el presupuesto: \n"
					+ "Concepto: ");
			concepto = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Apellido: ");
			valor = sc.nextDouble();
			sc.nextLine();
			
			System.out.println("Direccion: ");
			iva = sc.nextInt();
			sc.nextLine();
			
			Presupuesto nuevoPresupuesto = new Presupuesto(concepto, valor, iva);
			
			clientes.get(posicionPresupuesto).agregarPresupuesto(nuevoPresupuesto);
			
			System.out.println("Despues: " + clientes.get(posicionPresupuesto).toString());
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
		
	}
	
	public static int obtenerPosicion(String nombre, String apellido, int identificador) {
		int i =0;
		int posicion = -1;
		boolean encontrado = false;
		
		while(i< clientes.size() && encontrado == false) {
			
			if(clientes.get(i).getNombre().equalsIgnoreCase(nombre) && clientes.get(i).getApellido().equalsIgnoreCase(apellido) || 
					clientes.get(i).getId() == identificador) {
				encontrado = true;
				posicion = i;
			}
			i++;
		}
		return posicion;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:05.476
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:05.476
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-28 12:37:06.558
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;
import java.util.Scanner;

public class Examen_Final_Leidy_Zhang {
	/*
	 * Nos piden elaborar un CRM de gestión de clientes y que tendrá que gestionar a través de un
	menú de opciones las altas de un cliente, consulta de un cliente o todos los clientes, generar presupuesto,
	modificación de un cliente y eliminación de un cliente.
	*/
	static Scanner sc = new Scanner(System.in);
	static ArrayList<Cliente> clientes = new ArrayList<Cliente>();
	static Cliente nuevo = new Cliente
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 1. Se debe definir un cliente predefinido con los diferentes datos aportados estáticamente y
correspondientes a cada uno de los atributos.
2. Defina un nuevo e-mail por el usuario creado.
3. Genere un presupuesto con el concepto “170h. Elaboración de una API”, precio 2410 € y
con un iva 21%.
4. Genere un presupuesto con el concepto “250h. Diseño imagen corporativa”, precio
3110€ y con un iva 21%.
5. Muestre la info del cliente que ha creado mediante el método consulta de un cliente.
6. Debe definirse otro cliente con los diferentes datos aportados por el usuario y
correspondientes a cada uno de los atributos.
7. Muestre la información de todos los clientes existentes.
8. Elimine el último cliente creado.
		 */
		
		

		int opcion = 0;
		int optionVer = 0;
		
		do {
			System.out.println("Menu \n"
					+ "0. Salir de la aplicacion \n"
					+ "1. Dar de alta un cliente \n"
					+ "2. Eliminar cliente \n"
					+ "3. Modificar un cliente \n"
					+ "4. Consultar datos de un cliente o todos \n"
					+ "5. Generar presupuesto");
			
			opcion = sc.nextInt();
			sc.nextLine();
			
		switch(opcion) {
		
			case 1:
				crearCliente();
				break;	
			case 2:
				eliminarCliente();
				break;
			case 3:
				modificarCliente();
				break;
			case 4:
				System.out.println("Quiere ver: \n"
						+ "1. Un solo cliente \n"
						+ "2. Todos los clientes");
				
				optionVer = sc.nextInt();
				sc.nextLine();
				
				verClientes(optionVer);
				
				break;
			case 5:
				crearPresupuesto();
				break;	
			default:
				System.out.println("Error. Introduce una opcion entre 1-5");
		}

		}while(opcion !=0);
		
		System.out.println("Has salido de la aplicacion");
	}

	public static void crearCliente() {
		
		/*
		 * La opción alta de un cliente debe nombrar el método altaClient(), y éste a la vez deberá
	pedir al usuario que introduzca por pantalla los datos mencionados anteriormente (o deberá
	de recibir estos datos por parámetro), exceptuando el id que se tendrá que autogenerar utilizando
	Math. Una vez que haya pedido todos estos datos, debe instanciarse el objeto de la clase y
	añadirlo a un array de clientes.
		 */
		String nombre = "";
		String apellido = "";
		String direccion = "";
		String email = "";
		String comentarios = "";
		
	
		System.out.println("Introduce los datos del nuevo cliente: \n"
				+ "Nombre: ");
		nombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		apellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Direccion: ");
		direccion = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Email: ");
		email = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Comentarios: ");
		comentarios = sc.nextLine();
		sc.nextLine();
		
		Cliente nuevoCliente = new Cliente(nombre, apellido, direccion, email, comentarios);
		clientes.add(nuevoCliente);
		
		
	}
	
	public static void eliminarCliente() {
		/*
		 * La opción de eliminar un cliente debe nombrar el método darDeBaixaClient(), y éste deberá
		pedir al usuario el nombre o el id del cliente que quiere darse de baja y si el cliente está dentro de
		el array, lo eliminaremos y mostraremos un mensaje por pantalla informando al usuario que hemos eliminado
		el cliente. Si no hemos encontrado al cliente dentro del array, avisaremos al usuario diciendo que el cliente no
		estaba dentro de nuestra aplicación.
		 */
		
		String eliminarNombre = "";
		String eliminarApellido = "";
		int eliminarId = 0;
		int posicionEliminar = 0;
		
	
		System.out.println("Introduce el nombre del cliente que quieres eliminar: \n"
				+ "Nombre: ");
		eliminarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		eliminarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		eliminarId = sc.nextInt();
		sc.nextLine();
		
		
		posicionEliminar = obtenerPosicion(eliminarNombre, eliminarApellido, eliminarId);
		
		if(posicionEliminar != -1) {
			clientes.remove(posicionEliminar);
			System.out.println("El cliente se ha eliminado exitosamente");
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	}
	
	public static void modificarCliente() {
		/*
		 * La opción de modificar de un cliente, debe nombrar el método modificarClient(), y éste deberá
	pedir al usuario el nombre o el id del cliente que queremos modificar. Si lo tenemos en la aplicación, le
	preguntaremos si desea modificar cualquiera de los atributos, exceptuando el id. Haremos la modificación
	pertinente y avisaremos al usuario de que la modificación se ha realizado. En caso contrario, indicaremos en
	el usuario que no existe el cliente dentro de la aplicación.
		 */
		String modificarNombre = "";
		String modificarApellido = "";
		int modificarId = 0;
		int posicionModificar = 0;
		int opcionModificar = 0;
		
		String nuevoNombre = "";
		String nuevoApellido = "";
		String nuevoDireccion = "";
		String nuevoEmail = "";
		String nuevoComentarios = "";
		
	
		System.out.println("Introduce el cliente que quieres modificar: \n"
				+ "Nombre: ");
		modificarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		modificarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		modificarId = sc.nextInt();
		sc.nextLine();
		
		posicionModificar  = obtenerPosicion(modificarNombre, modificarApellido, modificarId);
		
		if(posicionModificar != -1) {
			//(String nombre, String apellido, String direccion, String email, String comentarios) 
			do {
				System.out.println("Que atributo quieres modificar? \n"
						+ "1. Nombre \n"
						+ "2. Apellido \n"
						+ "3. Direccion \n"
						+ "4. Email \n"
						+ "5. Comentarios \n"
						+ "0. Ninguno");
				
				switch(opcionModificar) {
					case 1:
						System.out.println("Introduce el cliente que quieres modificar: \n"
								+ "Nombre: ");
						nuevoNombre = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setNombre(nuevoNombre);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 2:
						System.out.println("Apellido: ");
						nuevoApellido = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setApellido(nuevoApellido);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 3:
						System.out.println("Direccion: ");
						nuevoDireccion = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setDireccion(nuevoDireccion);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 4:
						System.out.println("Email: ");
						nuevoEmail = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setEmail(nuevoEmail);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 5:
						System.out.println("Comentarios: ");
						nuevoComentarios = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setComentarios(nuevoComentarios);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					default: 
						System.out.println("Error, elija entre 1-5");
				
				}
				
			}while(opcionModificar != 0);
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	
		
		
		
	}
	
	public static void verClientes(int optionVer) {
		/*
		 * La opción de consulta de un cliente o de todos los clientes, debe nombrar el método
	verClientes(param1) donde se indicará un parámetro que permitirá mostrar un cliente o todos.
	
	En caso de desear visualizar un único cliente,
	 deberá pedir al usuario el nombre o id del cliente
	que quiere que mostramos por pantalla, si el cliente está en nuestra aplicación, 
	le mostraremos toda la
	información incluyendo los presupuestos vinculados, 
	
	si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	En caso de desear visualizar todos los clientes, muestre todos los atributos de cada cliente.
		 */
		
		String verNombre = "";
		String verApellido = "";
		int verId = 0;
		int verPosicion = 0;
		
		switch(optionVer) {
		case 1:

			System.out.println("Introduce el nombre del cliente que quieres ver: \n"
					+ "Nombre: ");
			verNombre = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el apellido: ");
			verApellido = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el id: ");
			verId = sc.nextInt();
			sc.nextLine();
			

			verPosicion = obtenerPosicion(verNombre, verApellido, verId);
			
			if(verPosicion != -1) {
				System.out.println(clientes.get(verPosicion).toString());
				
			}else {
				System.out.println("El cliente no esta dentro de la aplicacion");
			}
			
			break;
			
		case 2:
			System.out.println(clientes);
			break;
			
		default:
			System.out.println("Erorr, no has elejido entre 1-2");
		}
		
			
	}
	
	public static void crearPresupuesto() {
		/*
		 * La opción de generar presupuesto, debe nombrar el método crearPresupuesto(), y éste deberá
	pedir al usuario el nombre o el id del cliente para poder comprobar si el cliente está dentro de
	el array. Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes, almacenar el objeto correspondientemente vinculado al cliente y obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
		 */
		String presupuestoNombre = "";
		String presupuestoApellido = "";
		int presupuestoId = 0;
		int posicionPresupuesto = 0;
		
	
		System.out.println("Introduce el nombre del cliente para crear presupuesto: \n"
				+ "Nombre: ");
		presupuestoNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		presupuestoApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		presupuestoId = sc.nextInt();
		sc.nextLine();
		
		
		posicionPresupuesto = obtenerPosicion(presupuestoNombre, presupuestoApellido, presupuestoId);
		
		if(posicionPresupuesto != -1) {
			/*Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes,
	obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	*/
			String concepto = "";
			double valor =0d;
			int iva = 0;
			
			System.out.println("Antes: " + clientes.get(posicionPresupuesto).toString());
			
			System.out.println("Introduce los datos para generar el presupuesto: \n"
					+ "Concepto: ");
			concepto = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Apellido: ");
			valor = sc.nextDouble();
			sc.nextLine();
			
			System.out.println("Direccion: ");
			iva = sc.nextInt();
			sc.nextLine();
			
			Presupuesto nuevoPresupuesto = new Presupuesto(concepto, valor, iva);
			
			clientes.get(posicionPresupuesto).agregarPresupuesto(nuevoPresupuesto);
			
			System.out.println("Despues: " + clientes.get(posicionPresupuesto).toString());
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
		
	}
	
	public static int obtenerPosicion(String nombre, String apellido, int identificador) {
		int i =0;
		int posicion = -1;
		boolean encontrado = false;
		
		while(i< clientes.size() && encontrado == false) {
			
			if(clientes.get(i).getNombre().equalsIgnoreCase(nombre) && clientes.get(i).getApellido().equalsIgnoreCase(apellido) || 
					clientes.get(i).getId() == identificador) {
				encontrado = true;
				posicion = i;
			}
			i++;
		}
		return posicion;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:06.559
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:06.560
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-28 12:37:07.982
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;
import java.util.Scanner;

public class Examen_Final_Leidy_Zhang {
	/*
	 * Nos piden elaborar un CRM de gestión de clientes y que tendrá que gestionar a través de un
	menú de opciones las altas de un cliente, consulta de un cliente o todos los clientes, generar presupuesto,
	modificación de un cliente y eliminación de un cliente.
	*/
	static Scanner sc = new Scanner(System.in);
	static ArrayList<Cliente> clientes = new ArrayList<Cliente>();
	static Cliente nuevo = new Cliente<>
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 1. Se debe definir un cliente predefinido con los diferentes datos aportados estáticamente y
correspondientes a cada uno de los atributos.
2. Defina un nuevo e-mail por el usuario creado.
3. Genere un presupuesto con el concepto “170h. Elaboración de una API”, precio 2410 € y
con un iva 21%.
4. Genere un presupuesto con el concepto “250h. Diseño imagen corporativa”, precio
3110€ y con un iva 21%.
5. Muestre la info del cliente que ha creado mediante el método consulta de un cliente.
6. Debe definirse otro cliente con los diferentes datos aportados por el usuario y
correspondientes a cada uno de los atributos.
7. Muestre la información de todos los clientes existentes.
8. Elimine el último cliente creado.
		 */
		
		

		int opcion = 0;
		int optionVer = 0;
		
		do {
			System.out.println("Menu \n"
					+ "0. Salir de la aplicacion \n"
					+ "1. Dar de alta un cliente \n"
					+ "2. Eliminar cliente \n"
					+ "3. Modificar un cliente \n"
					+ "4. Consultar datos de un cliente o todos \n"
					+ "5. Generar presupuesto");
			
			opcion = sc.nextInt();
			sc.nextLine();
			
		switch(opcion) {
		
			case 1:
				crearCliente();
				break;	
			case 2:
				eliminarCliente();
				break;
			case 3:
				modificarCliente();
				break;
			case 4:
				System.out.println("Quiere ver: \n"
						+ "1. Un solo cliente \n"
						+ "2. Todos los clientes");
				
				optionVer = sc.nextInt();
				sc.nextLine();
				
				verClientes(optionVer);
				
				break;
			case 5:
				crearPresupuesto();
				break;	
			default:
				System.out.println("Error. Introduce una opcion entre 1-5");
		}

		}while(opcion !=0);
		
		System.out.println("Has salido de la aplicacion");
	}

	public static void crearCliente() {
		
		/*
		 * La opción alta de un cliente debe nombrar el método altaClient(), y éste a la vez deberá
	pedir al usuario que introduzca por pantalla los datos mencionados anteriormente (o deberá
	de recibir estos datos por parámetro), exceptuando el id que se tendrá que autogenerar utilizando
	Math. Una vez que haya pedido todos estos datos, debe instanciarse el objeto de la clase y
	añadirlo a un array de clientes.
		 */
		String nombre = "";
		String apellido = "";
		String direccion = "";
		String email = "";
		String comentarios = "";
		
	
		System.out.println("Introduce los datos del nuevo cliente: \n"
				+ "Nombre: ");
		nombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		apellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Direccion: ");
		direccion = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Email: ");
		email = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Comentarios: ");
		comentarios = sc.nextLine();
		sc.nextLine();
		
		Cliente nuevoCliente = new Cliente(nombre, apellido, direccion, email, comentarios);
		clientes.add(nuevoCliente);
		
		
	}
	
	public static void eliminarCliente() {
		/*
		 * La opción de eliminar un cliente debe nombrar el método darDeBaixaClient(), y éste deberá
		pedir al usuario el nombre o el id del cliente que quiere darse de baja y si el cliente está dentro de
		el array, lo eliminaremos y mostraremos un mensaje por pantalla informando al usuario que hemos eliminado
		el cliente. Si no hemos encontrado al cliente dentro del array, avisaremos al usuario diciendo que el cliente no
		estaba dentro de nuestra aplicación.
		 */
		
		String eliminarNombre = "";
		String eliminarApellido = "";
		int eliminarId = 0;
		int posicionEliminar = 0;
		
	
		System.out.println("Introduce el nombre del cliente que quieres eliminar: \n"
				+ "Nombre: ");
		eliminarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		eliminarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		eliminarId = sc.nextInt();
		sc.nextLine();
		
		
		posicionEliminar = obtenerPosicion(eliminarNombre, eliminarApellido, eliminarId);
		
		if(posicionEliminar != -1) {
			clientes.remove(posicionEliminar);
			System.out.println("El cliente se ha eliminado exitosamente");
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	}
	
	public static void modificarCliente() {
		/*
		 * La opción de modificar de un cliente, debe nombrar el método modificarClient(), y éste deberá
	pedir al usuario el nombre o el id del cliente que queremos modificar. Si lo tenemos en la aplicación, le
	preguntaremos si desea modificar cualquiera de los atributos, exceptuando el id. Haremos la modificación
	pertinente y avisaremos al usuario de que la modificación se ha realizado. En caso contrario, indicaremos en
	el usuario que no existe el cliente dentro de la aplicación.
		 */
		String modificarNombre = "";
		String modificarApellido = "";
		int modificarId = 0;
		int posicionModificar = 0;
		int opcionModificar = 0;
		
		String nuevoNombre = "";
		String nuevoApellido = "";
		String nuevoDireccion = "";
		String nuevoEmail = "";
		String nuevoComentarios = "";
		
	
		System.out.println("Introduce el cliente que quieres modificar: \n"
				+ "Nombre: ");
		modificarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		modificarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		modificarId = sc.nextInt();
		sc.nextLine();
		
		posicionModificar  = obtenerPosicion(modificarNombre, modificarApellido, modificarId);
		
		if(posicionModificar != -1) {
			//(String nombre, String apellido, String direccion, String email, String comentarios) 
			do {
				System.out.println("Que atributo quieres modificar? \n"
						+ "1. Nombre \n"
						+ "2. Apellido \n"
						+ "3. Direccion \n"
						+ "4. Email \n"
						+ "5. Comentarios \n"
						+ "0. Ninguno");
				
				switch(opcionModificar) {
					case 1:
						System.out.println("Introduce el cliente que quieres modificar: \n"
								+ "Nombre: ");
						nuevoNombre = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setNombre(nuevoNombre);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 2:
						System.out.println("Apellido: ");
						nuevoApellido = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setApellido(nuevoApellido);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 3:
						System.out.println("Direccion: ");
						nuevoDireccion = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setDireccion(nuevoDireccion);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 4:
						System.out.println("Email: ");
						nuevoEmail = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setEmail(nuevoEmail);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 5:
						System.out.println("Comentarios: ");
						nuevoComentarios = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setComentarios(nuevoComentarios);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					default: 
						System.out.println("Error, elija entre 1-5");
				
				}
				
			}while(opcionModificar != 0);
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	
		
		
		
	}
	
	public static void verClientes(int optionVer) {
		/*
		 * La opción de consulta de un cliente o de todos los clientes, debe nombrar el método
	verClientes(param1) donde se indicará un parámetro que permitirá mostrar un cliente o todos.
	
	En caso de desear visualizar un único cliente,
	 deberá pedir al usuario el nombre o id del cliente
	que quiere que mostramos por pantalla, si el cliente está en nuestra aplicación, 
	le mostraremos toda la
	información incluyendo los presupuestos vinculados, 
	
	si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	En caso de desear visualizar todos los clientes, muestre todos los atributos de cada cliente.
		 */
		
		String verNombre = "";
		String verApellido = "";
		int verId = 0;
		int verPosicion = 0;
		
		switch(optionVer) {
		case 1:

			System.out.println("Introduce el nombre del cliente que quieres ver: \n"
					+ "Nombre: ");
			verNombre = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el apellido: ");
			verApellido = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el id: ");
			verId = sc.nextInt();
			sc.nextLine();
			

			verPosicion = obtenerPosicion(verNombre, verApellido, verId);
			
			if(verPosicion != -1) {
				System.out.println(clientes.get(verPosicion).toString());
				
			}else {
				System.out.println("El cliente no esta dentro de la aplicacion");
			}
			
			break;
			
		case 2:
			System.out.println(clientes);
			break;
			
		default:
			System.out.println("Erorr, no has elejido entre 1-2");
		}
		
			
	}
	
	public static void crearPresupuesto() {
		/*
		 * La opción de generar presupuesto, debe nombrar el método crearPresupuesto(), y éste deberá
	pedir al usuario el nombre o el id del cliente para poder comprobar si el cliente está dentro de
	el array. Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes, almacenar el objeto correspondientemente vinculado al cliente y obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
		 */
		String presupuestoNombre = "";
		String presupuestoApellido = "";
		int presupuestoId = 0;
		int posicionPresupuesto = 0;
		
	
		System.out.println("Introduce el nombre del cliente para crear presupuesto: \n"
				+ "Nombre: ");
		presupuestoNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		presupuestoApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		presupuestoId = sc.nextInt();
		sc.nextLine();
		
		
		posicionPresupuesto = obtenerPosicion(presupuestoNombre, presupuestoApellido, presupuestoId);
		
		if(posicionPresupuesto != -1) {
			/*Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes,
	obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	*/
			String concepto = "";
			double valor =0d;
			int iva = 0;
			
			System.out.println("Antes: " + clientes.get(posicionPresupuesto).toString());
			
			System.out.println("Introduce los datos para generar el presupuesto: \n"
					+ "Concepto: ");
			concepto = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Apellido: ");
			valor = sc.nextDouble();
			sc.nextLine();
			
			System.out.println("Direccion: ");
			iva = sc.nextInt();
			sc.nextLine();
			
			Presupuesto nuevoPresupuesto = new Presupuesto(concepto, valor, iva);
			
			clientes.get(posicionPresupuesto).agregarPresupuesto(nuevoPresupuesto);
			
			System.out.println("Despues: " + clientes.get(posicionPresupuesto).toString());
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
		
	}
	
	public static int obtenerPosicion(String nombre, String apellido, int identificador) {
		int i =0;
		int posicion = -1;
		boolean encontrado = false;
		
		while(i< clientes.size() && encontrado == false) {
			
			if(clientes.get(i).getNombre().equalsIgnoreCase(nombre) && clientes.get(i).getApellido().equalsIgnoreCase(apellido) || 
					clientes.get(i).getId() == identificador) {
				encontrado = true;
				posicion = i;
			}
			i++;
		}
		return posicion;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:07.983
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:07.984
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-28 12:37:08.513
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;
import java.util.Scanner;

public class Examen_Final_Leidy_Zhang {
	/*
	 * Nos piden elaborar un CRM de gestión de clientes y que tendrá que gestionar a través de un
	menú de opciones las altas de un cliente, consulta de un cliente o todos los clientes, generar presupuesto,
	modificación de un cliente y eliminación de un cliente.
	*/
	static Scanner sc = new Scanner(System.in);
	static ArrayList<Cliente> clientes = new ArrayList<Cliente>();
	static Cliente nuevo = new Cliente
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 1. Se debe definir un cliente predefinido con los diferentes datos aportados estáticamente y
correspondientes a cada uno de los atributos.
2. Defina un nuevo e-mail por el usuario creado.
3. Genere un presupuesto con el concepto “170h. Elaboración de una API”, precio 2410 € y
con un iva 21%.
4. Genere un presupuesto con el concepto “250h. Diseño imagen corporativa”, precio
3110€ y con un iva 21%.
5. Muestre la info del cliente que ha creado mediante el método consulta de un cliente.
6. Debe definirse otro cliente con los diferentes datos aportados por el usuario y
correspondientes a cada uno de los atributos.
7. Muestre la información de todos los clientes existentes.
8. Elimine el último cliente creado.
		 */
		
		

		int opcion = 0;
		int optionVer = 0;
		
		do {
			System.out.println("Menu \n"
					+ "0. Salir de la aplicacion \n"
					+ "1. Dar de alta un cliente \n"
					+ "2. Eliminar cliente \n"
					+ "3. Modificar un cliente \n"
					+ "4. Consultar datos de un cliente o todos \n"
					+ "5. Generar presupuesto");
			
			opcion = sc.nextInt();
			sc.nextLine();
			
		switch(opcion) {
		
			case 1:
				crearCliente();
				break;	
			case 2:
				eliminarCliente();
				break;
			case 3:
				modificarCliente();
				break;
			case 4:
				System.out.println("Quiere ver: \n"
						+ "1. Un solo cliente \n"
						+ "2. Todos los clientes");
				
				optionVer = sc.nextInt();
				sc.nextLine();
				
				verClientes(optionVer);
				
				break;
			case 5:
				crearPresupuesto();
				break;	
			default:
				System.out.println("Error. Introduce una opcion entre 1-5");
		}

		}while(opcion !=0);
		
		System.out.println("Has salido de la aplicacion");
	}

	public static void crearCliente() {
		
		/*
		 * La opción alta de un cliente debe nombrar el método altaClient(), y éste a la vez deberá
	pedir al usuario que introduzca por pantalla los datos mencionados anteriormente (o deberá
	de recibir estos datos por parámetro), exceptuando el id que se tendrá que autogenerar utilizando
	Math. Una vez que haya pedido todos estos datos, debe instanciarse el objeto de la clase y
	añadirlo a un array de clientes.
		 */
		String nombre = "";
		String apellido = "";
		String direccion = "";
		String email = "";
		String comentarios = "";
		
	
		System.out.println("Introduce los datos del nuevo cliente: \n"
				+ "Nombre: ");
		nombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		apellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Direccion: ");
		direccion = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Email: ");
		email = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Comentarios: ");
		comentarios = sc.nextLine();
		sc.nextLine();
		
		Cliente nuevoCliente = new Cliente(nombre, apellido, direccion, email, comentarios);
		clientes.add(nuevoCliente);
		
		
	}
	
	public static void eliminarCliente() {
		/*
		 * La opción de eliminar un cliente debe nombrar el método darDeBaixaClient(), y éste deberá
		pedir al usuario el nombre o el id del cliente que quiere darse de baja y si el cliente está dentro de
		el array, lo eliminaremos y mostraremos un mensaje por pantalla informando al usuario que hemos eliminado
		el cliente. Si no hemos encontrado al cliente dentro del array, avisaremos al usuario diciendo que el cliente no
		estaba dentro de nuestra aplicación.
		 */
		
		String eliminarNombre = "";
		String eliminarApellido = "";
		int eliminarId = 0;
		int posicionEliminar = 0;
		
	
		System.out.println("Introduce el nombre del cliente que quieres eliminar: \n"
				+ "Nombre: ");
		eliminarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		eliminarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		eliminarId = sc.nextInt();
		sc.nextLine();
		
		
		posicionEliminar = obtenerPosicion(eliminarNombre, eliminarApellido, eliminarId);
		
		if(posicionEliminar != -1) {
			clientes.remove(posicionEliminar);
			System.out.println("El cliente se ha eliminado exitosamente");
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	}
	
	public static void modificarCliente() {
		/*
		 * La opción de modificar de un cliente, debe nombrar el método modificarClient(), y éste deberá
	pedir al usuario el nombre o el id del cliente que queremos modificar. Si lo tenemos en la aplicación, le
	preguntaremos si desea modificar cualquiera de los atributos, exceptuando el id. Haremos la modificación
	pertinente y avisaremos al usuario de que la modificación se ha realizado. En caso contrario, indicaremos en
	el usuario que no existe el cliente dentro de la aplicación.
		 */
		String modificarNombre = "";
		String modificarApellido = "";
		int modificarId = 0;
		int posicionModificar = 0;
		int opcionModificar = 0;
		
		String nuevoNombre = "";
		String nuevoApellido = "";
		String nuevoDireccion = "";
		String nuevoEmail = "";
		String nuevoComentarios = "";
		
	
		System.out.println("Introduce el cliente que quieres modificar: \n"
				+ "Nombre: ");
		modificarNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Apellido: ");
		modificarApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		modificarId = sc.nextInt();
		sc.nextLine();
		
		posicionModificar  = obtenerPosicion(modificarNombre, modificarApellido, modificarId);
		
		if(posicionModificar != -1) {
			//(String nombre, String apellido, String direccion, String email, String comentarios) 
			do {
				System.out.println("Que atributo quieres modificar? \n"
						+ "1. Nombre \n"
						+ "2. Apellido \n"
						+ "3. Direccion \n"
						+ "4. Email \n"
						+ "5. Comentarios \n"
						+ "0. Ninguno");
				
				switch(opcionModificar) {
					case 1:
						System.out.println("Introduce el cliente que quieres modificar: \n"
								+ "Nombre: ");
						nuevoNombre = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setNombre(nuevoNombre);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 2:
						System.out.println("Apellido: ");
						nuevoApellido = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setApellido(nuevoApellido);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 3:
						System.out.println("Direccion: ");
						nuevoDireccion = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setDireccion(nuevoDireccion);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 4:
						System.out.println("Email: ");
						nuevoEmail = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setEmail(nuevoEmail);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					case 5:
						System.out.println("Comentarios: ");
						nuevoComentarios = sc.nextLine();
						sc.nextLine();
						clientes.get(posicionModificar).setComentarios(nuevoComentarios);
						System.out.println("Se ha modificado correctamente");
						
						break;
						
					default: 
						System.out.println("Error, elija entre 1-5");
				
				}
				
			}while(opcionModificar != 0);
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
	
		
		
		
	}
	
	public static void verClientes(int optionVer) {
		/*
		 * La opción de consulta de un cliente o de todos los clientes, debe nombrar el método
	verClientes(param1) donde se indicará un parámetro que permitirá mostrar un cliente o todos.
	
	En caso de desear visualizar un único cliente,
	 deberá pedir al usuario el nombre o id del cliente
	que quiere que mostramos por pantalla, si el cliente está en nuestra aplicación, 
	le mostraremos toda la
	información incluyendo los presupuestos vinculados, 
	
	si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	En caso de desear visualizar todos los clientes, muestre todos los atributos de cada cliente.
		 */
		
		String verNombre = "";
		String verApellido = "";
		int verId = 0;
		int verPosicion = 0;
		
		switch(optionVer) {
		case 1:

			System.out.println("Introduce el nombre del cliente que quieres ver: \n"
					+ "Nombre: ");
			verNombre = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el apellido: ");
			verApellido = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Introduce el id: ");
			verId = sc.nextInt();
			sc.nextLine();
			

			verPosicion = obtenerPosicion(verNombre, verApellido, verId);
			
			if(verPosicion != -1) {
				System.out.println(clientes.get(verPosicion).toString());
				
			}else {
				System.out.println("El cliente no esta dentro de la aplicacion");
			}
			
			break;
			
		case 2:
			System.out.println(clientes);
			break;
			
		default:
			System.out.println("Erorr, no has elejido entre 1-2");
		}
		
			
	}
	
	public static void crearPresupuesto() {
		/*
		 * La opción de generar presupuesto, debe nombrar el método crearPresupuesto(), y éste deberá
	pedir al usuario el nombre o el id del cliente para poder comprobar si el cliente está dentro de
	el array. Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes, almacenar el objeto correspondientemente vinculado al cliente y obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
		 */
		String presupuestoNombre = "";
		String presupuestoApellido = "";
		int presupuestoId = 0;
		int posicionPresupuesto = 0;
		
	
		System.out.println("Introduce el nombre del cliente para crear presupuesto: \n"
				+ "Nombre: ");
		presupuestoNombre = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el apellido: ");
		presupuestoApellido = sc.nextLine();
		sc.nextLine();
		
		System.out.println("Introduce el id: ");
		presupuestoId = sc.nextInt();
		sc.nextLine();
		
		
		posicionPresupuesto = obtenerPosicion(presupuestoNombre, presupuestoApellido, presupuestoId);
		
		if(posicionPresupuesto != -1) {
			/*Si el cliente está en nuestra aplicación, 
	obtendremos todos los atributos del cliente, 
	se pedirá al usuario que indique el concepto, 
	valor e iva, por nombrar el método generarPresupuesto() de
	la clase Clientes,
	obtener una
	respuesta como el ejemplo indicado anteriormente. Si no está, informaremos al usuario diciendo que el
	cliente que nos ha pedido no está dentro de nuestra aplicación.
	*/
			String concepto = "";
			double valor =0d;
			int iva = 0;
			
			System.out.println("Antes: " + clientes.get(posicionPresupuesto).toString());
			
			System.out.println("Introduce los datos para generar el presupuesto: \n"
					+ "Concepto: ");
			concepto = sc.nextLine();
			sc.nextLine();
			
			System.out.println("Apellido: ");
			valor = sc.nextDouble();
			sc.nextLine();
			
			System.out.println("Direccion: ");
			iva = sc.nextInt();
			sc.nextLine();
			
			Presupuesto nuevoPresupuesto = new Presupuesto(concepto, valor, iva);
			
			clientes.get(posicionPresupuesto).agregarPresupuesto(nuevoPresupuesto);
			
			System.out.println("Despues: " + clientes.get(posicionPresupuesto).toString());
			
		}else {
			System.out.println("El cliente no esta dentro de la aplicacion");
		}
		
		
	}
	
	public static int obtenerPosicion(String nombre, String apellido, int identificador) {
		int i =0;
		int posicion = -1;
		boolean encontrado = false;
		
		while(i< clientes.size() && encontrado == false) {
			
			if(clientes.get(i).getNombre().equalsIgnoreCase(nombre) && clientes.get(i).getApellido().equalsIgnoreCase(apellido) || 
					clientes.get(i).getId() == identificador) {
				encontrado = true;
				posicion = i;
			}
			i++;
		}
		return posicion;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-28 12:37:08.514
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-28 12:37:08.514
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3748)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:541)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-29 16:33:07.968
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Pilots extends Workers{
	
	int height;
	int weight;
	

	public Pilots(String name, String last, int age, int time, int salary, int height, int weight) {
		super(name, last, age, time, salary);
		this.height = height;
		this.weight = weight;
	
	}
	
	public int getHeight() {
		return this.height;
	}
	
	public int getWeight() {
		return this.height;
	}
	
	public void setHeight(int height) {
		this.height = height;
	}
	
	public void setWeight(int weight) {
		this.weight = weight;
	}
	
	//metodos generales
	public void addSalary() {
		 = (super.getSalary() * super.getTime()
	}
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-29 16:33:07.971
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-29 16:33:07.971
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-29 16:33:15.781
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Pilots extends Workers{
	
	int height;
	int weight;
	

	public Pilots(String name, String last, int age, int time, int salary, int height, int weight) {
		super(name, last, age, time, salary);
		this.height = height;
		this.weight = weight;
	
	}
	
	public int getHeight() {
		return this.height;
	}
	
	public int getWeight() {
		return this.height;
	}
	
	public void setHeight(int height) {
		this.height = height;
	}
	
	public void setWeight(int weight) {
		this.weight = weight;
	}
	
	//metodos generales
	public void addSalary() {
		super.setSalary(height); = (super.getSalary() * super.getTime()
	}
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-29 16:33:15.781
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-29 16:33:15.783
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-29 16:33:21.858
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Pilots extends Workers{
	
	int height;
	int weight;
	

	public Pilots(String name, String last, int age, int time, int salary, int height, int weight) {
		super(name, last, age, time, salary);
		this.height = height;
		this.weight = weight;
	
	}
	
	public int getHeight() {
		return this.height;
	}
	
	public int getWeight() {
		return this.height;
	}
	
	public void setHeight(int height) {
		this.height = height;
	}
	
	public void setWeight(int weight) {
		this.weight = weight;
	}
	
	//metodos generales
	public void addSalary() {
		super.setSa); = (super.getSalary() * super.getTime()
	}
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-29 16:33:21.858
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-29 16:33:21.859
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-29 16:33:31.147
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Pilots extends Workers{
	
	int height;
	int weight;
	

	public Pilots(String name, String last, int age, int time, int salary, int height, int weight) {
		super(name, last, age, time, salary);
		this.height = height;
		this.weight = weight;
	
	}
	
	public int getHeight() {
		return this.height;
	}
	
	public int getWeight() {
		return this.height;
	}
	
	public void setHeight(int height) {
		this.height = height;
	}
	
	public void setWeight(int weight) {
		this.weight = weight;
	}
	
	//metodos generales
	public void addSalary() {
		 = (super.getSalary() * super.getTime()
	}
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-29 16:33:31.147
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-29 16:33:31.148
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-29 16:33:33.363
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Pilots extends Workers{
	
	int height;
	int weight;
	

	public Pilots(String name, String last, int age, int time, int salary, int height, int weight) {
		super(name, last, age, time, salary);
		this.height = height;
		this.weight = weight;
	
	}
	
	public int getHeight() {
		return this.height;
	}
	
	public int getWeight() {
		return this.height;
	}
	
	public void setHeight(int height) {
		this.height = height;
	}
	
	public void setWeight(int weight) {
		this.weight = weight;
	}
	
	//metodos generales
	public void addSalary() {
		 = (super.getSalary() * super.getTime()
	}
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-06-29 16:33:33.364
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-06-29 16:33:33.365
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-07-03 22:34:14.206 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=17.0.7
java.vendor=Eclipse Adoptium
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_AF
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/leidy/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/leidy/.eclipse_keyring

!ENTRY ch.qos.logback.classic 1 0 2023-07-03 22:34:16.690
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-07-03 22:34:19.937
!MESSAGE Logback config file: /Users/leidy/eclipse-workspace/.metadata/.plugins/org.eclipse.m2e.logback/logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-07-03 22:34:24.629
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-03 22:34:24.630
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-03 22:34:24.630
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2023-07-13 09:31:00.640 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=17.0.7
java.vendor=Eclipse Adoptium
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_AF
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/leidy/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/leidy/.eclipse_keyring

!ENTRY ch.qos.logback.classic 1 0 2023-07-13 09:31:03.277
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-07-13 09:31:06.887
!MESSAGE Logback config file: /Users/leidy/eclipse-workspace/.metadata/.plugins/org.eclipse.m2e.logback/logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-07-13 09:31:11.767
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-13 09:31:11.767
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-13 09:31:11.767
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)

!ENTRY org.eclipse.jdt.ui 4 10001 2023-07-13 09:33:05.094
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Error in Java Model (code 1006): <project root> [in CATA1] is not on its project's build path
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getRawClasspathEntry(PackageFragmentRoot.java:613)
	at org.eclipse.jdt.internal.corext.buildpath.ClasspathModifier.filtersSet(ClasspathModifier.java:647)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer$PackageLabelProvider.getForeground(DialogPackageExplorer.java:210)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getForeground(DelegatingStyledCellLabelProvider.java:143)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getForeground(DecoratingStyledCellLabelProvider.java:145)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:126)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:144)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:970)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:126)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1048)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:427)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2107)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:864)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:842)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:611)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:790)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalInitializeTree(AbstractTreeViewer.java:1610)
	at org.eclipse.jface.viewers.TreeViewer.internalInitializeTree(TreeViewer.java:787)
	at org.eclipse.jface.viewers.AbstractTreeViewer.lambda$1(AbstractTreeViewer.java:1595)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1398)
	at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:365)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1359)
	at org.eclipse.jface.viewers.AbstractTreeViewer.inputChanged(AbstractTreeViewer.java:1589)
	at org.eclipse.jface.viewers.ContentViewer.setInput(ContentViewer.java:282)
	at org.eclipse.jface.viewers.StructuredViewer.setInput(StructuredViewer.java:1632)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setInput(DialogPackageExplorer.java:424)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage.doUpdateUI(NewSourceContainerWorkbookPage.java:137)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4368)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3991)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1034)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.changeToNewProject(NewJavaProjectWizardPageTwo.java:175)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.createProvisonalProject(NewJavaProjectWizardPageTwo.java:482)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.setVisible(NewJavaProjectWizardPageTwo.java:133)
	at org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1253)
	at org.eclipse.jface.wizard.WizardDialog.lambda$3(WizardDialog.java:1223)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:918)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4646)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1524)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1547)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1532)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1325)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4413)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3989)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4646)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1524)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1547)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1532)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1325)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4413)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3989)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 1006 2023-07-13 09:33:05.096
!MESSAGE <project root> [in CATA1] is not on its project's build path

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 09:36:21.448
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalStateException: null is not part of a compilation unit or class file
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:845)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1112)
	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.addSimilarTypeProposals(UnresolvedElementsSubProcessor.java:900)
	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.getTypeProposals(UnresolvedElementsSubProcessor.java:683)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:424)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:361)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:381)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:341)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:336)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:465)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectProposals(JavaCorrectionProcessor.java:284)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.computeQuickAssistProposals(JavaCorrectionProcessor.java:247)
	at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:71)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.lambda$0(ContentAssistant.java:2063)
	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4905)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:2062)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:2059)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:577)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.lambda$0(CompletionProposalPopup.java:507)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:502)
	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1873)
	at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:113)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:194)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:201)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSelectAnnotationRulerAction.runWithEvent(JavaSelectAnnotationRulerAction.java:101)
	at org.eclipse.ui.texteditor.AbstractRulerActionDelegate.runWithEvent(AbstractRulerActionDelegate.java:112)
	at org.eclipse.ui.internal.handlers.ActionDelegateHandlerProxy.execute(ActionDelegateHandlerProxy.java:281)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.ui.actions.ContributedAction.runWithEvent(ContributedAction.java:176)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.triggerAction(AbstractTextEditor.java:3025)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.lambda$0(AbstractTextEditor.java:3039)
	at org.eclipse.swt.widgets.Display.runTimers(Display.java:4601)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3980)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.ui 4 4 2023-07-13 09:36:21.510
!MESSAGE An error occurred while computing quick fixes. Check log for details.
!SUBENTRY 1 org.eclipse.jdt.ui 4 0 2023-07-13 09:36:21.510
!MESSAGE Exception while processing quick fixes or quick assists
!SUBENTRY 2 org.eclipse.jdt.ui 4 4 2023-07-13 09:36:21.510
!MESSAGE Exception while processing quick fixes or quick assists
!STACK 0
java.lang.IllegalStateException: null is not part of a compilation unit or class file
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:845)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1112)
	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.addSimilarTypeProposals(UnresolvedElementsSubProcessor.java:900)
	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.getTypeProposals(UnresolvedElementsSubProcessor.java:683)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:424)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:361)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:381)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:341)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:336)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:465)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectProposals(JavaCorrectionProcessor.java:284)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.computeQuickAssistProposals(JavaCorrectionProcessor.java:247)
	at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:71)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.lambda$0(ContentAssistant.java:2063)
	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4905)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:2062)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:2059)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:577)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.lambda$0(CompletionProposalPopup.java:507)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:502)
	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1873)
	at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:113)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:194)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:201)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSelectAnnotationRulerAction.runWithEvent(JavaSelectAnnotationRulerAction.java:101)
	at org.eclipse.ui.texteditor.AbstractRulerActionDelegate.runWithEvent(AbstractRulerActionDelegate.java:112)
	at org.eclipse.ui.internal.handlers.ActionDelegateHandlerProxy.execute(ActionDelegateHandlerProxy.java:281)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.ui.actions.ContributedAction.runWithEvent(ContributedAction.java:176)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.triggerAction(AbstractTextEditor.java:3025)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.lambda$0(AbstractTextEditor.java:3039)
	at org.eclipse.swt.widgets.Display.runTimers(Display.java:4601)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3980)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
